---
group:
  title: 中等
  order: 2
order: 15
description: '给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。'
keywords: [全栈, 紫升, 力扣, 三数之和]
toc: content
---

# 15. ⭐️​三数之和

## 题目描述 <Badge type="warning">中等</Badge> <Badge type="success">数组</Badge> <Badge type="success">双指针</Badge> <Badge type="success">排序</Badge>

给你一个整数数组 `nums`，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k`，同时还满足 `nums[i] + nums[j+ nums[k] == 0`。请你返回所有和为 `0`。请你返回所有和为 `0` 且不重复的三元组。

:::info{title=注意}
答案中不可以包含重复的三元素。
:::

**示例 1**：

> **输入**：`nums = [-1, 0, 1, 2, -1, -4]`<br/>
> **输出**：`[[-1, -1, 2], [-1, 0, 1]]`<br/>
> **解释**：<br/>
> `nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0`。<br/>
> `nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0`。<br/>
> `nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0`。<br/>
> 不同的三元组是 [-1, 0, 1] 和 `[-1, -1, 2]`

**示例 2**：

> **输入**：`nums = [0, 1 ,1]`<br/>
> **输出**：`[]`<br/>
> 解释：唯一可能的三元组和不为 0。

**示例 3**：

> **输入**：`nums = [0, 0, 0]`
> **输出**：`[[0, 0, 0]]`
> 解释：唯一可能的三元组和为 0。

**提示：**

- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

## 思路

`nSum` 系列问题的核心思路就是**排序**+**双指针**。

先给数组从小到大排序，然后双指针 `left` 和 `right` 分别在数组开头和结尾，这样就可以控制 `nums[left]` 和 `nums[right]` 这个两数之和的大小：

如果你想让它俩的和大一些，就让 `left++`，如果你想让它俩的和小一些，就让 `right--`。

![三数之和](https://cdn.jsdelivr.net/gh/youngjuning/images@main/1745219268550.png)

基于两数之和可以得到一个万能函数 `nSumTarget`，扩展出 n 数之和的解法。

## 解法代码

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
  let ans = [];
  const len = nums.length;
  if (nums === null || len < 3) return ans;
  nums.sort((a, b) => a - b); // 排序
  for(let i =0; i < len; i++) {
    if(nums[i] > 0) break; // 如果当前数字大于 0，则三数之和一定大于 0，所以结束循环
    if(i > 0 && nums[i] == nums[i-1]) continue; // 去重
    let left = i + 1;
    let right = len - 1;
    while(left < right) {
      const sum = nums[i] + nums[left] + nums[right];
      if (sum == 0) {
        ans.push(nums[i], nums[left], nums[right]);
        while(left < right && nums[left] === nums[left+1]) left++; // 去重
        while(left < right && nums[right] === nums[right-1]) right; // 去重
        left++;
        right--;
      } else if(sum < 0) {
        left++;
      } else if(sum > 0) {
        right--;
      }
    }
  }
  return ans;
}
```
